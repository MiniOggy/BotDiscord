const { Client, GatewayIntentBits, ActivityType } = require('discord.js');
const { joinVoiceChannel, createAudioPlayer, createAudioResource, AudioPlayerStatus, getVoiceConnection } = require('@discordjs/voice');
const googleTTS = require('google-tts-api');
const ytdl = require('ytdl-core');

const client = new Client({
  intents: [
    GatewayIntentBits.Guilds,
    GatewayIntentBits.GuildMessages,
    GatewayIntentBits.MessageContent,
    GatewayIntentBits.GuildVoiceStates,
  ],
});

client.once('ready', () => {
  console.log(`${client.user.tag} ƒë√£ s·∫µn s√†ng!`);
  client.user.setPresence({
    status: "idle",
    activities: [{ name: "M√© hosting bot s·∫≠p ho√†i", type: ActivityType.Custom }]
  });
});

client.on('messageCreate', async message => {
  if (!message.guild) return;
  const args = message.content.split(' ').slice(1);

  switch (message.content.split(' ')[0].toLowerCase()) {
    case '_s':
      await handleTTSCommand(message, args.join(' '));
      break;
    case '_p':
      await handlePlayCommand(message, args.join(' '));
      break;
    case '_dis':
      await handleDisconnectCommand(message);
      break;
    case '_sk':
      await handleSkipCommand(message);
      break;
    case '_xoatn':
      await handleBulkDeleteCommand(message, args[0]);
      break;
    case '_tubi':
      message.reply("H√£y t·ª´ bi tha th·ª© cho m·ªçi ng∆∞·ªùi, t·∫øt ƒë·∫øn xu√¢n d√¨a ƒë·ª´ng ƒë·ªï m√°u n·ªØa üôè");
      break;
    case '_che':
      message.reply("Sao m·∫•y ng∆∞·ªùi l·∫°i ch√™ t√¥i, th·∫≠t l√† t√†n √°c m√† üòø");
      break;
    case '_bi l√† ai':
      message.reply("L√† Hellobine, l√∫c m·ªõi v√†o nh√† Raccoon Bi kh√° l√† tr·∫ßm t√≠nh nh∆∞ng v·ªÅ sau l·∫°i l√† 1 phi√™n b·∫£n kh√°c, ho·∫°t b√°t h∆°n, vui h∆°n nh∆∞ng k√©o theo ƒë√≥ l√† s·ª± v√¥ tri m·ªói khi t√¨m ƒë∆∞·ªùng ho·∫∑c t√¨m hi·ªÉu t√≠nh nƒÉng c·ªßa game v√¨ th·∫ø d√¢n gian c√≤n g·ªçi Bi l√† **ƒê√¢n B√¨**\n\n C√¢u c·ª≠a mi·ªáng: M·ªçe, tr·ªùi ∆°i ƒë·ª´ng n∆∞·ªõng qu·∫£ m·ªçng n·ªØa, cho th√∫ ƒÉn ƒëi, n√≥ tr·∫ßm c·∫£m th√¨ cho ƒëi chich");
      break;
    case '_lenh':
      message.reply("T√≠nh NƒÉng Hi·ªán C√≥:\n\n‚úÖ **TTS ( Text To Speech )**: N√≥i thay l·ªùi b·∫°n t·ª´ vƒÉn b·∫£n, d√πng l·ªánh _s\n‚úÖ **X√≥a Tin Nh·∫Øn**: X√≥a tin nh·∫Øn v·ªõi t·ªëc ƒë·ªô √°nh s√°ng, d√πng l·ªánh _xoatn sau ƒë√≥ nh·∫≠p s·ªë l∆∞·ª£ng.\n **üé∂Play Music**: D√πng l·ªánh _p sau ƒë√≥ Link nh·∫°c t·ª´ Youtube.\n **ü§êSkip Music**: B·ªè qua b√†i nh·∫°c ƒëang h√°t b·∫±ng l·ªánh _sk\n\n *Ch√∫c b·∫°n ch∆°i game vui v·∫ª ü•∞*");
      break;
    // X·ª≠ l√Ω c√°c l·ªánh kh√°c...
  }
});

async function handleTTSCommand(message, text) {
  if (!message.member.voice.channel) {
    return message.reply("V√†o room ƒëi mu·ªën g√¨ t√¥i n√≥i h·ªô cho, kh√¥ng v√†o m√† c·ª© l√≥i l√≥i r·ªìi k√™u t√¥i ra");
  }
  if (text.length === 0) {
    return message.reply('B·∫°n c·∫ßn ph·∫£i cung c·∫•p m·ªôt ƒëo·∫°n vƒÉn ƒë·ªÉ t√¥i c√≥ th·ªÉ ƒë·ªçc.');
  }
  if (text.length > 200) {
    return message.reply('D√†i qu√° l√† tao n·∫±m ng·∫•t ra ƒë√¢y ƒë·∫•y, kh√¥ng n√≥i n·ªØa ƒë√¢u');
  }

  const url = await googleTTS.getAudioUrl(text, {
    lang: 'vi',
    slow: false,
  });
  playAudio(message.member.voice.channel, url);
}

async function handlePlayCommand(message, url) {
  if (!message.member.voice.channel) {
    return message.reply('B·∫°n c·∫ßn ph·∫£i ·ªü trong m·ªôt k√™nh tho·∫°i.');
  }
  if (url.length === 0) {
    return message.reply('B·∫°n c·∫ßn ph·∫£i cung c·∫•p m·ªôt URL.');
  }

  try {
    const songInfo = await ytdl.getInfo(url);
    const stream = ytdl.downloadFromInfo(songInfo, { filter: 'audioonly' });
    playAudio(message.member.voice.channel, stream);
    message.reply(`üé∂ ƒêang b·∫•m b√†i "**${songInfo.videoDetails.title}**"`);
  } catch (error) {
    console.error(`Kh√¥ng th·ªÉ ph√°t video n√†y: ${error.message}`);
    message.reply('Kh√¥ng th·ªÉ ph√°t video n√†y.');
  }
}

async function handleDisconnectCommand(message) {
  if (!message.member.voice.channel) {
    return message.reply('B·∫°n c·∫ßn ph·∫£i ·ªü trong m·ªôt k√™nh tho·∫°i.');
  }
  const connection = getVoiceConnection(message.guild.id);
  if (connection) {
    connection.destroy();
  }
}

async function handleSkipCommand(message) {
  const player = getPlayer(message.guild.id);
  if (!player) {
    return message.reply("Kh√¥ng c√≥ b√†i h√°t n√†o ƒëang ph√°t.");
  }
  player.stop();
message.reply(`ü§êƒê√£ ng·∫≠m m·ªìm l·∫°i v√† b·ªè qua b√†i h√°t v·ª´a r·ªìi`);
}

async function handleBulkDeleteCommand(message, amount) {
  if (!message.member.permissions.has("MANAGE_MESSAGES")) {
    return message.reply("B·∫°n c·∫ßn c√≥ quy·ªÅn qu·∫£n l√Ω tin nh·∫Øn ƒë·ªÉ s·ª≠ d·ª•ng l·ªánh n√†y.");
  }
  const deleteCount = parseInt(amount, 10);
  if (isNaN(deleteCount) || deleteCount < 1 || deleteCount > 100) {
    return message.reply("Vui l√≤ng cung c·∫•p m·ªôt s·ªë t·ª´ 1 ƒë·∫øn 100 tin nh·∫Øn ƒë·ªÉ x√≥a.");
  }
  const fetched = await message.channel.messages.fetch({ limit: deleteCount });
  message.channel.bulkDelete(fetched, true).catch(error => message.reply(`Kh√¥ng th·ªÉ x√≥a tin nh·∫Øn v√¨: ${error}`));
}

function playAudio(voiceChannel, source) {
  const connection = joinVoiceChannel({
    channelId: voiceChannel.id,
    guildId: voiceChannel.guild.id,
    adapterCreator: voiceChannel.guild.voiceAdapterCreator,
  });
  
  const player = createAudioPlayer();
  player.on(AudioPlayerStatus.Idle, () => console.log('Ho√†n th√†nh ph√°t!'));
  player.on('error', error => console.error(`L·ªói ph√°t: ${error.message}`));

  let resource = createAudioResource(source);
  player.play(resource);
  connection.subscribe(player);
}

function getPlayer(guildId) {
  const connection = getVoiceConnection(guildId);
  return connection ? connection.state.subscription.player : null;
}

client.login('MTIwMzA5NTQ2MDQzNzMwMzM2OA.Gjg3ju.uP5Yvw8MPepnR-8WC1p5Sj7FivtT1kvp7CDGAs'); // Thay th·∫ø 'YOUR_BOT_TOKEN' b·∫±ng token th·ª±c c·ªßa bot
